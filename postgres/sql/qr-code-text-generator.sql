-- QR Code Text Generator
--
-- Generate a QR code using pure SQL (with payload length safety checks)
-- Author: Tanel Poder [tanelpoder.com] (with OpenAI Codex CLI doing the work)
-- Source: <https://github.com/tanelpoder/tpt-postgres/blob/main/demos/pqrsafe.sql>
--
-- This PostgreSQL script renders a Version 1-M QR code as ASCII art that
-- matches the output of qr --ascii. Run it through psql to generate a QR code
-- for short messages (up to 17 bytes in UTF-8).
--
-- This code was mainly generated by OpenAI Codex CLI, with some nudging and guidance from Tanel Poder_
--
-- ## Quick Start
--
-- ```sh
-- psql -f qr-code-text-generator.sql                                     # default payload "HELLO WORLD"
-- psql -v payload='Whats up?' -f qr-code-text-generator.sql              # named variable
-- psql -v 1='Hi!' -f qr-code-text-generator.sql                          # positional argument
-- psql -v payload='HELLO WORLD' -v mask=0 -f qr-code-text-generator.sql # max payload length check, allows forcing a specific mask
-- ```
--
-- If the payload is too long for Version 1-M, the script exits with an explanatory message.
--
-- ## How It Works
--
-- The script:
--
-- -- - Picks the optimal encoding mode (numeric → alphanumeric → byte) and assembles Version 1-M data + error correction codewords (RS(10,16)).
-- - Places function patterns, computes all eight QR masks using ISO/IEC penalty rules, and picks the lowest-penalty mask (or a user-specified override via `mask`/`force_mask`).
-- - Emits a 21×21 symbol with a 4-module quiet zone using CP437 half-block glyphs (`▀`, `▄`, `█`, `NBSP`) so the output exactly matches `qr --ascii`.
--
-- Version 1-M limits:
--
-- - Numeric mode: up to 34 digits
-- - Alphanumeric mode: up to 20 characters (A–Z 0–9 `$%*+-./:` and space)
-- - Byte mode: up to 14 bytes (UTF-8)
--
-- ### Verifying the Output
--
-- ```sh
-- psql -q -f qr-code-text-generator.sql > actual.txt
-- qr --ascii 'HELLO WORLD'              > expect.txt
-- diff -u actual.txt expect.txt
-- ```
--
-- Swap in any payload that respects the limits above to regression-test against the reference `qr` CLI.
--
-- ### Test Utilities
--
-- See the original repo <https://raw.githubusercontent.com/tanelpoder/tpt-postgres/>
--
-- - `./test.sh "PAYLOAD"` compares `psql -f pqr.sql` against `qr --ascii` for one payload.
-- - `./testloop.sh N` runs `N` randomized regression checks (alphanumeric payloads within Version 1-M capacity).

\pset tuples_only on
\pset format unaligned

\if :{?1}
  \set payload :1
\endif
\if :{?payload}
\else
  \set payload 'HELLO WORLD'
\endif

WITH
pre_params AS ( SELECT :'payload'::text AS s ),
pre_stats AS (
  SELECT s,
         length(s)     AS byte_len,
         char_length(s) AS char_len
  FROM pre_params
),
pre_chars AS (
  SELECT ps.pos,
         substr(ps.s, ps.pos, 1) AS ch,
         upper(substr(ps.s, ps.pos, 1)) AS chup
  FROM (
    SELECT ps.s, ps.char_len, generate_series(1, ps.char_len) AS pos
    FROM pre_stats ps
  ) ps
),
pre_numeric AS (
  SELECT COALESCE(bool_and(ch BETWEEN '0' AND '9'), FALSE) AS flag
  FROM pre_chars
),
pre_alnum_table(ch,val) AS (
  VALUES
    ('0',0),('1',1),('2',2),('3',3),('4',4),('5',5),('6',6),('7',7),('8',8),('9',9),
    ('A',10),('B',11),('C',12),('D',13),('E',14),('F',15),('G',16),('H',17),('I',18),('J',19),
    ('K',20),('L',21),('M',22),('N',23),('O',24),('P',25),('Q',26),('R',27),('S',28),('T',29),
    ('U',30),('V',31),('W',32),('X',33),('Y',34),('Z',35),(' ',36),('$',37),('%',38),('*',39),
    ('+',40),('-',41),('.',42),('/',43),(':',44)
),
pre_alnum_values AS (
  SELECT pc.pos,
         pat.val,
         CASE WHEN pat.val IS NOT NULL AND pc.ch = pc.chup THEN 1 ELSE 0 END AS is_valid
  FROM pre_chars pc
  LEFT JOIN pre_alnum_table pat ON pat.ch = pc.chup
),
pre_alnum AS (
  SELECT COALESCE(bool_and(is_valid=1), TRUE) AS ok
  FROM pre_alnum_values
),
pre_mode AS (
  SELECT CASE
           WHEN (SELECT flag FROM pre_numeric) THEN 'numeric'
           WHEN (SELECT ok FROM pre_alnum)
                AND (SELECT byte_len = char_len FROM pre_stats)
                THEN 'alnum'
           ELSE 'byte'
         END AS mode
  FROM pre_stats
),
pre_limits AS (
  SELECT mode,
         CASE mode
           WHEN 'numeric' THEN 34
           WHEN 'alnum'   THEN 20
           ELSE 14
         END AS max_len
  FROM pre_mode
)
SELECT (SELECT char_len FROM pre_stats) AS payload_len,
       (SELECT byte_len FROM pre_stats) AS payload_bytes,
       (SELECT mode FROM pre_mode) AS payload_mode,
       CASE
         WHEN (SELECT mode FROM pre_mode) = 'byte'
           THEN (SELECT byte_len FROM pre_stats) > (SELECT max_len FROM pre_limits)
         ELSE (SELECT char_len FROM pre_stats) > (SELECT max_len FROM pre_limits)
       END AS payload_too_long
\gset

\if :payload_too_long
  \echo Version 1-M (ECC M) cannot encode :payload_mode payloads that long. Got :payload_len characters (:payload_bytes bytes).
  \quit
\endif

\if :{?mask}
  \set mask_override :mask
\elif :{?force_mask}
  \set mask_override :force_mask
\else
  \set mask_override ''
\endif

WITH RECURSIVE
-- ===== 0) INPUT =====
params AS ( SELECT :'payload'::text AS s ),

payload_stats AS (
  SELECT p.s,
         length(p.s)     AS byte_len,
         char_length(p.s) AS char_len
  FROM params p
),

payload_chars AS (
  SELECT ps.pos,
         substr(ps.s, ps.pos, 1) AS ch,
         upper(substr(ps.s, ps.pos, 1)) AS chup
  FROM (
    SELECT ps.s, generate_series(1, ps.char_len) AS pos
    FROM payload_stats ps
  ) ps
),

numeric_values AS (
  SELECT pc.pos,
         pc.ch,
         CASE WHEN pc.ch BETWEEN '0' AND '9' THEN 1 ELSE 0 END AS is_digit
  FROM payload_chars pc
),

use_numeric AS (
  SELECT COALESCE(bool_and(is_digit = 1), FALSE) AS flag
  FROM numeric_values
),

numeric_groups AS (
  SELECT floor((pos-1)/3) AS grp,
         string_agg(ch, '' ORDER BY pos) AS chunk
  FROM numeric_values
  WHERE is_digit = 1
  GROUP BY grp
),

numeric_bitstream AS (
  SELECT COALESCE(string_agg(
           CASE length(chunk)
             WHEN 3 THEN ((chunk::int)::bit(10))::text
             WHEN 2 THEN ((chunk::int)::bit(7))::text
             WHEN 1 THEN ((chunk::int)::bit(4))::text
           END,
           '' ORDER BY grp), '') AS t
  FROM numeric_groups
),

alnum_table(ch,val) AS (
  VALUES
    ('0',0),('1',1),('2',2),('3',3),('4',4),('5',5),('6',6),('7',7),('8',8),('9',9),
    ('A',10),('B',11),('C',12),('D',13),('E',14),('F',15),('G',16),('H',17),('I',18),('J',19),
    ('K',20),('L',21),('M',22),('N',23),('O',24),('P',25),('Q',26),('R',27),('S',28),('T',29),
    ('U',30),('V',31),('W',32),('X',33),('Y',34),('Z',35),(' ',36),('$',37),('%',38),('*',39),
    ('+',40),('-',41),('.',42),('/',43),(':',44)
),

alnum_values AS (
  SELECT pc.pos,
         pc.ch,
         at.val,
         CASE WHEN at.val IS NOT NULL AND pc.ch = pc.chup THEN 1 ELSE 0 END AS is_valid
  FROM payload_chars pc
  LEFT JOIN alnum_table at ON at.ch = pc.chup
),

alnum_status AS (
  SELECT COALESCE(bool_and(is_valid=1), TRUE) AS ok
  FROM alnum_values
),

use_alnum AS (
  SELECT ((SELECT ok FROM alnum_status)
          AND (SELECT byte_len = char_len FROM payload_stats)
          AND NOT (SELECT flag FROM use_numeric)) AS flag
),

alnum_groups AS (
  SELECT floor((pos-1)/2) AS grp,
         array_agg(val ORDER BY pos) AS vals
  FROM alnum_values
  WHERE val IS NOT NULL
  GROUP BY grp
),

alnum_bitstream AS (
  SELECT COALESCE(string_agg(
           CASE WHEN array_length(vals,1) = 2
                THEN (((vals[1]*45 + vals[2])::bit(11))::text)
                ELSE ((vals[1]::bit(6))::text)
           END,
           '' ORDER BY grp), '') AS t
  FROM alnum_groups
),

-- ===== 1) Bits & bytes helpers =====
bin8(n,pos,txt) AS (
  SELECT n,0, CASE WHEN ((n>>7)&1)=1 THEN '1' ELSE '0' END
  FROM generate_series(0,255) AS n
  UNION ALL
  SELECT n,pos+1, txt || CASE WHEN ((n>>(7-(pos+1)))&1)=1 THEN '1' ELSE '0' END
  FROM bin8 WHERE pos<7
),
bin8_final AS ( SELECT DISTINCT n,txt FROM bin8 WHERE pos=7 ),

-- ===== 2) Build v1-M data (16 bytes) and ECC (10 bytes) =====
octets AS (
  SELECT convert_to(ps.s,'UTF8') AS b,
         ps.byte_len,
         ps.char_len
  FROM payload_stats ps
),
data_bytes(idx,b) AS (
  SELECT gs, get_byte(o.b,gs) FROM octets o
  CROSS JOIN generate_series(0,length(o.b)-1) gs
),
mode_bits AS (
  SELECT CASE
           WHEN (SELECT flag FROM use_numeric) THEN '0001'
           WHEN (SELECT flag FROM use_alnum)  THEN '0010'
           ELSE '0100'
         END AS t
),
len_bits  AS (
  SELECT CASE WHEN (SELECT flag FROM use_numeric)
              THEN ((SELECT char_len FROM payload_stats)::bit(10))::text
              WHEN (SELECT flag FROM use_alnum)
              THEN ((SELECT char_len FROM payload_stats)::bit(9))::text
              ELSE ((SELECT byte_len FROM payload_stats)::bit(8))::text
         END AS t
),
data_bits_byte AS (
  SELECT COALESCE(string_agg(b8.txt,'' ORDER BY db.idx), '') AS t
  FROM data_bytes db JOIN bin8_final b8 ON b8.n=db.b
),
data_bits AS (
  SELECT CASE WHEN (SELECT flag FROM use_numeric)
              THEN (SELECT t FROM numeric_bitstream)
              WHEN (SELECT flag FROM use_alnum)
              THEN (SELECT t FROM alnum_bitstream)
              ELSE (SELECT t FROM data_bits_byte)
         END AS t
),
bitstream0 AS ( SELECT (SELECT t FROM mode_bits) || (SELECT t FROM len_bits) || (SELECT t FROM data_bits) AS t ),
bitstream1 AS ( SELECT t || repeat('0', LEAST(4, GREATEST(0, 128 - length(t)))) AS t FROM bitstream0 ),
bitstream2 AS ( SELECT t || repeat('0', (8 - (length(t)%8))%8) AS t FROM bitstream1 ),
pad_needed  AS ( SELECT GREATEST(0,16 - (length(t)/8)) n, t FROM bitstream2 ),
padded_stream AS (
  SELECT pad_needed.t ||
         COALESCE(string_agg(CASE WHEN (i%2)=1 THEN '11101100' ELSE '00010001' END,''
                                ORDER BY i),'') AS t
  FROM pad_needed
  LEFT JOIN generate_series(1,pad_needed.n) g(i) ON TRUE
  GROUP BY pad_needed.t
),
data_cw AS (
  SELECT array_agg(('B'||substr(t,1+8*i,8))::bit(8)::int ORDER BY i) AS data_arr
  FROM padded_stream, generate_series(0,15) g(i)
),

-- ---- Reed–Solomon RS(10) over GF(256) (poly 0x11D) ----
gf_exp(i,val) AS (
  SELECT 0,1
  UNION ALL
  SELECT i+1, CASE WHEN val>=128 THEN (((val<<1)#29)&255) ELSE ((val<<1)&255) END
  FROM gf_exp WHERE i<254
),
gf_log  AS (SELECT val AS expv, i AS logv FROM gf_exp),
exp_tab AS (SELECT i,   val AS expv FROM gf_exp),
gen(idx,val) AS (
  VALUES (1,216),(2,194),(3,159),(4,111),(5,199),(6,94),(7,95),(8,113),(9,157),(10,193)
),
rs(pos,rem) AS (
  SELECT 0, ARRAY[0,0,0,0,0,0,0,0,0,0]::int[]
  UNION ALL
  SELECT
    pos+1,
    (
      SELECT array_agg(
               (s.arr)[g.idx] #
               CASE WHEN f.fb=0 OR g.val=0 THEN 0
                    ELSE (SELECT e.expv FROM exp_tab e
                          WHERE e.i = (
                            ((SELECT l1.logv FROM gf_log l1 WHERE l1.expv=f.fb) +
                             (SELECT l2.logv FROM gf_log l2 WHERE l2.expv=g.val)) % 255))
               END
             ORDER BY g.idx)
      FROM gen g
      CROSS JOIN LATERAL (
        SELECT (rem[1] # (SELECT data_arr[pos+1] FROM data_cw)) AS fb
      ) f
      CROSS JOIN LATERAL (
        SELECT (rem[2:10] || 0)::int[] AS arr
      ) s
    )::int[]
  FROM rs WHERE pos<16
),
ecc_cw AS ( SELECT rem AS ecc_arr FROM rs ORDER BY pos DESC LIMIT 1 ),
all_cw AS ( SELECT array_cat((SELECT data_arr FROM data_cw),(SELECT ecc_arr FROM ecc_cw)) AS cw ),

-- ===== 3) Build 21×21 matrix with function patterns =====
sz AS ( SELECT 21 AS n ),
coords AS (
  SELECT x,y
  FROM generate_series(0,(SELECT n-1 FROM sz)) x
  CROSS JOIN generate_series(0,(SELECT n-1 FROM sz)) y
),

-- Exact 7×7 finder patterns (TL, TR, BL)
finder_fill AS (
  WITH fpos AS (
    SELECT 0 AS ox, 0 AS oy UNION ALL
    SELECT 14, 0 UNION ALL
    SELECT 0, 14
  )
  SELECT c.x, c.y,
         CASE
           WHEN EXISTS (
             SELECT 1 FROM fpos p
             WHERE c.x BETWEEN p.ox AND p.ox+6 AND c.y BETWEEN p.oy AND p.oy+6
           )
           THEN (
             -- local (lx,ly) inside a 7x7 box anchored at (ox,oy)
             WITH loc AS (
               SELECT (c.x - p.ox) AS lx, (c.y - p.oy) AS ly
               FROM fpos p
               WHERE c.x BETWEEN p.ox AND p.ox+6 AND c.y BETWEEN p.oy AND p.oy+6
               LIMIT 1
             )
             SELECT CASE
                      WHEN (SELECT lx FROM loc) IN (0,6) OR (SELECT ly FROM loc) IN (0,6) THEN 1 -- outer border
                      WHEN (SELECT lx FROM loc) BETWEEN 2 AND 4 AND (SELECT ly FROM loc) BETWEEN 2 AND 4 THEN 1 -- inner 3x3
                      ELSE 0 -- white ring
                    END
           )
           ELSE NULL
         END AS m
  FROM coords c
),

finder_sep AS (
  WITH fpos AS (
    SELECT 0 AS ox, 0 AS oy UNION ALL
    SELECT 14, 0 UNION ALL
    SELECT 0, 14
  ),
  border AS (
    SELECT p.ox, p.oy,
           generate_series(p.ox-1, p.ox+7) AS x,
           p.oy - 1 AS y
    FROM fpos p
    UNION ALL
    SELECT p.ox, p.oy,
           generate_series(p.ox-1, p.ox+7) AS x,
           p.oy + 7 AS y
    FROM fpos p
    UNION ALL
    SELECT p.ox, p.oy,
           p.ox - 1 AS x,
           generate_series(p.oy-1, p.oy+7) AS y
    FROM fpos p
    UNION ALL
    SELECT p.ox, p.oy,
           p.ox + 7 AS x,
           generate_series(p.oy-1, p.oy+7) AS y
    FROM fpos p
  )
  SELECT DISTINCT x,y, 0 AS m
  FROM border
  WHERE x BETWEEN 0 AND 20 AND y BETWEEN 0 AND 20
),

-- Timing patterns (row 6 and col 6), skipping finder areas
timing AS (
  SELECT x,y,
         CASE
           WHEN (y=6 OR x=6)
            AND NOT (
              (x BETWEEN 0 AND 6 AND y BETWEEN 0 AND 6) OR
              (x BETWEEN 14 AND 20 AND y BETWEEN 0 AND 6) OR
              (x BETWEEN 0 AND 6 AND y BETWEEN 14 AND 20)
            )
           THEN ((CASE WHEN y=6 THEN x ELSE y END + 1) % 2)::int
           ELSE NULL
         END AS m
  FROM coords
),

-- Format information positions (two copies, LSB-first order)
format_coords(copy, bit_idx, x, y) AS (
  VALUES
    -- column copy (along x=8)
    (0, 0, 8, 0),(0, 1, 8, 1),(0, 2, 8, 2),(0, 3, 8, 3),(0, 4, 8, 4),(0, 5, 8, 5),
    (0, 6, 8, 7),(0, 7, 8, 8),(0, 8, 8,14),(0, 9, 8,15),(0,10, 8,16),(0,11, 8,17),
    (0,12, 8,18),(0,13, 8,19),(0,14, 8,20),
    -- row copy (along y=8)
    (1, 0,20, 8),(1, 1,19, 8),(1, 2,18, 8),(1, 3,17, 8),(1, 4,16, 8),(1, 5,15, 8),
    (1, 6,14, 8),(1, 7,13, 8),(1, 8, 7, 8),(1, 9, 5, 8),(1,10, 4, 8),(1,11, 3, 8),
    (1,12, 2, 8),(1,13, 1, 8),(1,14, 0, 8)
),
format_locations AS (
  SELECT DISTINCT x,y FROM format_coords
),
dark_module AS ( SELECT 8 AS x, 13 AS y ),

-- Reserved cells: finder, timing, format, dark module
reserved AS (
  SELECT x,y, TRUE AS r FROM finder_fill WHERE m IS NOT NULL
  UNION ALL
  SELECT x,y, TRUE FROM timing WHERE m IS NOT NULL
  UNION ALL
  SELECT x,y, TRUE FROM finder_sep
  UNION ALL
  SELECT x,y, TRUE FROM format_locations
  UNION ALL
  SELECT x,y, TRUE FROM dark_module
),

-- ===== 4) Zig-zag data placement order (right→left in column pairs; skip x=6) =====
colpairs AS (
  SELECT row_number() OVER () AS cp,
         val AS x_right,
         val-1 AS x_left
  FROM unnest(ARRAY[20,18,16,14,12,10,8,5,3,1]) AS val
),
scan AS (
  -- rows for each column pair; vertical direction alternates by pair
  SELECT p.cp,
         s.x,
         CASE WHEN (p.cp % 2)=1 THEN 20 - s.yv ELSE s.yv END AS y,
         s.yv,
         s.col_rank
  FROM colpairs p
  CROSS JOIN LATERAL (
    SELECT yv, p.x_right AS x, 0 AS col_rank FROM generate_series(0,20) AS yv
    UNION ALL
    SELECT yv, p.x_left, 1 FROM generate_series(0,20) AS yv
  ) s
),
scan_data_slots AS (
  SELECT s.*,
         row_number() OVER (ORDER BY cp, s.yv, s.col_rank) AS ord
  FROM scan s
  WHERE NOT EXISTS (SELECT 1 FROM reserved r WHERE r.x=s.x AND r.y=s.y)
),

-- Flatten codewords to bitstream (MSB→LSB per byte)
cw_bits AS (
  SELECT string_agg(b8.txt,'' ORDER BY u.ord) AS bits
  FROM all_cw,
       LATERAL unnest(cw) WITH ORDINALITY AS u(val, ord)
       JOIN bin8_final b8 ON b8.n = u.val
),
bits_indexed AS (
  SELECT ord, SUBSTRING((SELECT bits FROM cw_bits) FROM ord FOR 1) AS bit
  FROM generate_series(1,(SELECT length(bits) FROM cw_bits)) ord
),

-- Place data bits (unmasked)
data_modules AS (
  SELECT s.x,s.y,
         CASE WHEN bi.bit='1' THEN 1 ELSE 0 END AS m
  FROM scan_data_slots s
  LEFT JOIN bits_indexed bi ON bi.ord = s.ord
),

mask_patterns(mask_id) AS (
  VALUES (0),(1),(2),(3),(4),(5),(6),(7)
),

masked_data AS (
  SELECT mp.mask_id,
         dm.x,
         dm.y,
         CASE
           WHEN CASE mp.mask_id
                  WHEN 0 THEN ((dm.x + dm.y) % 2 = 0)
                  WHEN 1 THEN (dm.y % 2 = 0)
                  WHEN 2 THEN (dm.x % 3 = 0)
                  WHEN 3 THEN ((dm.x + dm.y) % 3 = 0)
                  WHEN 4 THEN (((dm.y / 2) + (dm.x / 3)) % 2 = 0)
                  WHEN 5 THEN (((dm.x * dm.y) % 2) + ((dm.x * dm.y) % 3) = 0)
                  WHEN 6 THEN ((((dm.x * dm.y) % 2) + ((dm.x * dm.y) % 3)) % 2 = 0)
                  WHEN 7 THEN ((((dm.x + dm.y) % 2) + ((dm.x * dm.y) % 3)) % 2 = 0)
                END
           THEN 1 - dm.m ELSE dm.m
         END AS m
  FROM data_modules dm
  CROSS JOIN mask_patterns mp
),

format_base AS (
  SELECT mp.mask_id,
         (0 << 3) | mp.mask_id AS data5
  FROM mask_patterns mp
),
format_calc AS (
  SELECT mask_id, 14 AS bit_pos, (data5 << 10) AS value
  FROM format_base
  UNION ALL
  SELECT mask_id,
         bit_pos - 1,
         CASE WHEN (value & (1 << bit_pos)) <> 0
              THEN value # (1335 << (bit_pos - 10))
              ELSE value
         END
  FROM format_calc
  WHERE bit_pos >= 10
),
format_bits AS (
  SELECT fb.mask_id,
         (((fb.data5 << 10) | fc.value) # 21522) AS bits15
  FROM format_base fb
  JOIN format_calc fc ON fb.mask_id = fc.mask_id
  WHERE fc.bit_pos = 9
),
format_modules AS (
  SELECT fb.mask_id,
         fc.x,
         fc.y,
         ((fb.bits15 >> fc.bit_idx) & 1) AS m
  FROM format_bits fb
  JOIN format_coords fc ON TRUE
),
dark_modules AS (
  SELECT mp.mask_id AS mask_id, d.x, d.y, 1 AS m
  FROM dark_module d
  CROSS JOIN mask_patterns mp
),

matrix_masked_raw AS (
  SELECT mp.mask_id,
         c.x,
         c.y,
         COALESCE(f.m, fs.m, t.m,
                  md.m, 0) AS m
  FROM mask_patterns mp
  CROSS JOIN coords c
  LEFT JOIN finder_fill f ON f.x=c.x AND f.y=c.y
  LEFT JOIN finder_sep  fs ON fs.x=c.x AND fs.y=c.y
  LEFT JOIN timing      t ON t.x=c.x AND t.y=c.y
  LEFT JOIN masked_data md ON md.mask_id=mp.mask_id AND md.x=c.x AND md.y=c.y
),

matrix_masked AS (
  SELECT mmr.mask_id,
         mmr.x,
         mmr.y,
         COALESCE(fmt.m, dm2.m, mmr.m) AS m
  FROM matrix_masked_raw mmr
  LEFT JOIN format_modules fmt ON fmt.mask_id=mmr.mask_id AND fmt.x=mmr.x AND fmt.y=mmr.y
  LEFT JOIN dark_modules dm2 ON dm2.mask_id=mmr.mask_id AND dm2.x=mmr.x AND dm2.y=mmr.y
),

row_marks AS (
  SELECT mask_id, y, x, m,
         CASE WHEN lag(m) OVER (PARTITION BY mask_id, y ORDER BY x) = m THEN 0 ELSE 1 END AS start_flag
  FROM matrix_masked_raw
),
row_groups AS (
  SELECT mask_id, y, x, m,
         SUM(start_flag) OVER (PARTITION BY mask_id, y ORDER BY x ROWS UNBOUNDED PRECEDING) AS grp
  FROM row_marks
),
row_runs AS (
  SELECT mask_id, y, grp, COUNT(*) AS run_len
  FROM row_groups
  GROUP BY mask_id, y, grp
),
col_marks AS (
  SELECT mask_id, x, y, m,
         CASE WHEN lag(m) OVER (PARTITION BY mask_id, x ORDER BY y) = m THEN 0 ELSE 1 END AS start_flag
  FROM matrix_masked_raw
),
col_groups AS (
  SELECT mask_id, x, y, m,
         SUM(start_flag) OVER (PARTITION BY mask_id, x ORDER BY y ROWS UNBOUNDED PRECEDING) AS grp
  FROM col_marks
),
col_runs AS (
  SELECT mask_id, x, grp, COUNT(*) AS run_len
  FROM col_groups
  GROUP BY mask_id, x, grp
),
n1_penalty AS (
  SELECT mask_id,
         SUM(CASE WHEN run_len >= 5 THEN 3 + (run_len - 5) ELSE 0 END) AS penalty
  FROM (
    SELECT * FROM row_runs
    UNION ALL
    SELECT * FROM col_runs
  ) u
  GROUP BY mask_id
),

n2_penalty AS (
  SELECT mask_id, COUNT(*) * 3 AS penalty
  FROM (
    SELECT m.mask_id
    FROM matrix_masked_raw m
    JOIN matrix_masked_raw m1 ON m1.mask_id=m.mask_id AND m1.x=m.x+1 AND m1.y=m.y
    JOIN matrix_masked_raw m2 ON m2.mask_id=m.mask_id AND m2.x=m.x AND m2.y=m.y+1
    JOIN matrix_masked_raw m3 ON m3.mask_id=m.mask_id AND m3.x=m.x+1 AND m3.y=m.y+1
    WHERE m.x < 20 AND m.y < 20
      AND m.m = m1.m AND m.m = m2.m AND m.m = m3.m
    GROUP BY m.mask_id, m.x, m.y
  ) sq
  GROUP BY mask_id
),

row_strings AS (
  SELECT mask_id, y, string_agg(m::text, '' ORDER BY x) AS bits
  FROM matrix_masked_raw
  GROUP BY mask_id, y
),
col_strings AS (
  SELECT mask_id, x, string_agg(m::text, '' ORDER BY y) AS bits
  FROM matrix_masked_raw
  GROUP BY mask_id, x
),
n3_penalty AS (
  SELECT mask_id, COUNT(*) * 40 AS penalty
  FROM (
    SELECT mask_id FROM row_strings, regexp_matches(bits, '10111010000', 'g')
    UNION ALL
    SELECT mask_id FROM row_strings, regexp_matches(bits, '00001011101', 'g')
    UNION ALL
    SELECT mask_id FROM col_strings, regexp_matches(bits, '10111010000', 'g')
    UNION ALL
    SELECT mask_id FROM col_strings, regexp_matches(bits, '00001011101', 'g')
  ) hits
  GROUP BY mask_id
),

dark_counts AS (
  SELECT mask_id,
         SUM(m) AS dark,
         COUNT(*) AS total
  FROM matrix_masked_raw
  GROUP BY mask_id
),
n4_penalty AS (
  SELECT mask_id,
         (floor(abs((dark::numeric * 100 / total) - 50) / 5) * 10)::int AS penalty
  FROM dark_counts
),

mask_scores AS (
  SELECT mp.mask_id,
         COALESCE(n1.penalty,0) + COALESCE(n2.penalty,0) +
         COALESCE(n3.penalty,0) + COALESCE(n4.penalty,0) AS total_penalty
  FROM mask_patterns mp
  LEFT JOIN n1_penalty n1 ON n1.mask_id = mp.mask_id
  LEFT JOIN n2_penalty n2 ON n2.mask_id = mp.mask_id
  LEFT JOIN n3_penalty n3 ON n3.mask_id = mp.mask_id
  LEFT JOIN n4_penalty n4 ON n4.mask_id = mp.mask_id
),
mask_choice AS (
  SELECT COALESCE(
           NULLIF(:'mask_override','')::int,
           (SELECT mask_id FROM mask_scores ORDER BY total_penalty, mask_id LIMIT 1)
         ) AS mask_id
),

final_matrix AS (
  SELECT mm.x, mm.y, mm.m
  FROM matrix_masked mm
  JOIN mask_choice mc ON mc.mask_id = mm.mask_id
),

render_coords AS (
  SELECT x, y
  FROM generate_series(0, 28) AS x
  CROSS JOIN generate_series(0, 28) AS y
),

render_matrix AS (
  SELECT rc.x,
         rc.y,
         COALESCE(fm.m, 0) AS m
  FROM render_coords rc
  LEFT JOIN final_matrix fm
         ON fm.x = rc.x - 4
        AND fm.y = rc.y - 4
),

render_pairs AS (
  SELECT rm.x,
         (rm.y / 2) AS y_pair,
         (rm.y % 2) AS half,
         rm.m
  FROM render_matrix rm
),

render_cells AS (
  SELECT x,
         y_pair,
         MAX(CASE WHEN half = 0 THEN m END) AS top,
         MAX(CASE WHEN half = 1 THEN m END) AS bottom
  FROM render_pairs
  GROUP BY x, y_pair
),

render_chars AS (
  SELECT x,
         y_pair,
         CASE
           WHEN top = 1 AND COALESCE(bottom, 0) = 1 THEN '█'
           WHEN top = 1 AND COALESCE(bottom, 0) = 0 THEN '▀'
           WHEN COALESCE(top, 0) = 0 AND COALESCE(bottom, 0) = 1 THEN '▄'
           ELSE chr(160)
         END AS ch
  FROM render_cells
),

render_lines AS (
  SELECT y_pair,
         string_agg(ch, '' ORDER BY x) AS line
  FROM render_chars
  GROUP BY y_pair
)

SELECT string_agg(line, E'\n' ORDER BY y_pair) AS qr_ascii
FROM render_lines;
